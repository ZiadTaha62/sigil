import type { SigilRegistry } from './options';

/** -----------------------------------------
 *  Options
 * ----------------------------------------- */

/**
 * Configuration options for the Sigil library.
 *
 * These options control runtime validation, inheritance checks, label autofill behavior,
 * and whether duplicate labels are permitted globally.
 *
 * Note: these options are read by runtime code during class decoration and inheritance
 * checks. Some behaviors (like `skipLabelInheritanceCheck`) are meant primarily for
 * development/test scenarios and may weaken type/identity guarantees when changed.
 */
export interface SigilOptions {
  /**
   * Validation rule applied to sigil labels before registration.
   *
   * - A function receives the label and must return `true` if valid.
   * - A `RegExp` must match the label.
   * - `null` disables validation entirely.
   *
   * Defaults to `null`.
   */
  labelValidation?: ((label: string) => boolean) | RegExp | null;

  /**
   * Skips the runtime check that prevents subclasses from inheriting
   * the same sigil label as their ancestors.
   *
   * When `false` (default), extending a sigil class without
   * using `WithSigil(newLabel)` decorator will throw an error if the label
   * is reused and `OPTIONS.autofillLabels` is set to `false`.
   *
   * Set this to `true` only if you intentionally want subclasses to inherit labels
   * from their ancestors (this weakens the uniqueness guarantees).
   *
   * WARNING:
   * Disabling inheritanceCheck removes guaranties by 'Sigil' or unique label for
   * each class and allow multiple child classes to use the same label which can
   * result on false 'isOfType' result. this options should be used in debugging
   * only to silence all errors but never in production.
   */
  skipLabelInheritanceCheck?: boolean;

  /**
   * When enabled, non-decorated subclasses that would otherwise inherit an ancestor's label
   * will be assigned an autogenerated random label (so that explicit labels stay unique).
   */
  autofillLabels?: boolean;

  /**
   * Marker used internally to control dev only checks to optimize performace while preserving
   * consistency for things like inheritance checks.
   * defaults to 'process.env.NODE_ENV !== "production'.
   */
  devMarker?: boolean;

  /**
   * Registry instance used to store and resolve sigil labels at runtime.
   *
   * - When `useGlobalRegistry` is `true` (default), this registry will be
   *   registered as the active global registry via `updateGlobalRegistry(...)`.
   * - When `useGlobalRegistry` is `false`, this registry is kept local and will
   *   not participate in global identity checks.
   *
   * IMPORTANT:
   * Replacing the registry via `updateOptions({ registry })` changes the active
   * registry used by Sigil, but consumers should always retrieve the registry
   * through `getRegistry()` rather than holding a long-lived reference.
   *
   * Defaults to a new `SigilRegistry` instance.
   *
   * WARNING:
   * Setting registry to null disables:
   * - Label re-use checks entirly.
   * - Feature relying on get(label) → class (e.g., deserialization)
   */
  registry?: SigilRegistry | null;

  /**
   * Controls whether the configured `registry` is stored in 'globalThis'.
   *
   * When `true` (default):
   * - The registry is registered globally
   * - All sigilized classes participate in the same identity space
   *
   * When `false`:
   * - No global registry is used
   * - Identity checks are limited to explicitly provided registry
   *
   * WARNING:
   * Disabling the global registry may lead to duplicate labels across
   * isolated registries and should only be done in advanced or test scenarios.
   */
  useGlobalRegistry?: boolean;

  /**
   * Controls whether the configured 'registry' should store class constructors.
   * This is useful if you want to use 'Sigil' while keeping the constructor private.
   *
   * Note that any feature relying on get(label) → class (e.g., deserialization) will
   * not work if set to 'true' as class is replaced with 'null'.
   *
   * When 'true' (default):
   * - Class passed will be stored in the registry map under its label.
   *
   * When 'false':
   * - Registry map stored only label key and class constructor is replaced with null ([label, null])
   */
  storeConstructor?: boolean;
}

/** -----------------------------------------
 *  Class and instance
 * ----------------------------------------- */

/**
 * Static-side interface describing methods and properties added to a class
 * constructor when it is sigilized.
 *
 * The properties and methods described here mirror the getters and static
 * predicates implemented by the `Sigilify` mixin.
 *
 * @template L - Narrow string literal type representing the label.
 * @template P - Optinal parent to extend its '__SIGIL_BRAND__'.
 */
interface ISigilStatic<L extends string = string, P extends Function = never> {
  /**
   * Compile-time nominal brand that encodes the class label `L` plus parent's brand keys `BrandOf<P>`.
   *
   * - Provides a *type-only* unique marker that makes instances nominally
   *   distinct by label and allows propagation/merging of brand keys across inheritance.
   * - Runtime: **no runtime value is required**; this property exists only for the type system.
   *
   * @remarks
   * Consumers should not read or set this property at runtime. It is used by helper
   * types (e.g. `SigilBrandOf`, `TypedSigil`) to extract/propagate compile-time brands.
   */
  readonly __SIGIL_BRAND__: Prettify<{ [k in L]: true } & SigilBrandOf<P>>;

  /** Class-level label constant (human readable). */
  readonly SigilLabel: string;

  /** Class-level unique symbol used as the runtime type identifier. */
  readonly SigilType: symbol;

  /**
   * Copy of the linearized sigil type symbol chain for the current constructor.
   * Useful for debugging and strict lineage comparisons.
   */
  readonly SigilTypeLineage: readonly symbol[];

  /**
   * Copy of the sigil type symbol set for the current constructor. Useful for
   * O(1) membership checks and debugging.
   */
  readonly SigilTypeSet: Readonly<Set<symbol>>;

  /**
   * Runtime check that determines whether `obj` is an instance produced by a
   * sigil class.
   *
   * Note: the concrete implementation provided by the mixin delegates to
   * `isSigilInstance`.
   *
   * @param obj - Value to test.
   * @returns Type guard narrowing `obj` to `ISigil`.
   */
  isSigilified(obj: unknown): obj is ISigil;

  /**
   * Check whether `other` is (or inherits from) the type represented by the
   * calling constructor. Uses the other instance's `SigilTypeSet` to check
   * membership. Works in O(1) and is reliable as long as `OPTIONS.skipLabelInheritanceCheck` is `false`.
   *
   * This replaces `instanceof` so that checks remain valid across bundles/realms
   * and when subclassing.
   *
   * @typeParam T - The specific sigil constructor (`this`).
   * @param this - The constructor performing the type check.
   * @param other - The object to test.
   * @returns A type guard asserting `other` is an instance of the constructor.
   */
  isOfType<T extends ISigil>(this: T, other: unknown): other is InstanceType<T>;

  /**
   * Strict lineage comparison: verifies that the calling constructor's type
   * lineage (by symbol) matches the `other`'s lineage element-by-element.
   *
   * Works in O(n) where `n` is the lineage length and is useful when order
   * and exact ancestry must be confirmed. reliable when `OPTIONS.skipLabelInheritanceCheck` is `false`.
   *
   * @typeParam T - The specific sigil constructor (`this`).
   * @param this - The constructor performing the strict check.
   * @param other - The object to test.
   * @returns A type guard asserting `other` is an instance whose lineage matches exactly.
   */
  isOfTypeStrict<T extends ISigil>(
    this: T,
    other: unknown
  ): other is InstanceType<T>;
}

/**
 * Instance-side interface describing properties present on sigil instances.
 * The methods mirror the instance helpers injected by the mixin.
 *
 * @template L - Narrow string literal type for the label returned by `getSigilLabel`.
 * @template P - Optinal parent to extend its '__SIGIL_BRAND__'.
 */
interface ISigilInstance<
  L extends string = string,
  P extends Function = never,
> {
  /**
   * Compile-time nominal brand that encodes the class label `L` plus parent's brand keys `BrandOf<P>`.
   *
   * - Provides a *type-only* unique marker that makes instances nominally
   *   distinct by label and allows propagation/merging of brand keys across inheritance.
   * - Runtime: **no runtime value is required**; this property exists only for the type system.
   *
   * @remarks
   * Consumers should not read or set this property at runtime. It is used by helper
   * types (e.g. `SigilBrandOf`, `TypedSigil`) to extract/propagate compile-time brands.
   */
  readonly __SIGIL_BRAND__: Prettify<{ [k in L]: true } & SigilBrandOf<P>>;
  /** Returns human-readable sigil label of the class constructor. */
  getSigilLabel(): string;
  /** Returns runtime sigil type symbol of the class constructor. */
  getSigilType(): symbol;
  /** Returns copy of sigil type symbol lineage of the class constructor. */
  getSigilTypeLineage(): readonly symbol[];
  /** Returns copy of sigil type symbol set of the class constructor. */
  getSigilTypeSet(): Readonly<Set<symbol>>;
}

/**
 * Combined constructor + static interface for a sigil class.
 *
 * This composes the instance-side shape (Constructor<ISigilInstance<L>>) with
 * the static-side interface (ISigilStatic<L>), matching the runtime shape added
 * by `Sigilify`.
 *
 * @template L - Narrow string literal type for the label.
 * @template P - Optinal parent to extend its '__SIGIL_BRAND__'.
 */
export type ISigil<
  L extends string = string,
  P extends Function = never,
> = Constructor<ISigilInstance<L, P>> & ISigilStatic<L, P>;

/** -----------------------------------------
 *  HOF pattern types
 * ----------------------------------------- */

/**
 * Combine an existing sigil constructor type `S` with a **new** label `L`,
 * while inheriting/propagating compile-time brands from an optional parent sigil `P`.
 *
 * @template S - The original Untyped Sigil constructor type being augmented.
 * @template L - The new label literal to associate with the resulting constructor.
 */
export type TypedSigil<S extends Function, L extends string = string> = S &
  AppendLabel<L> &
  Constructor<AppendLabel<L>>;

/**
 * Generic helper extract instance of the class even in protected and private constructors.
 */
export type GetInstance<T> = T extends { prototype: infer R }
  ? PrettifyBrand<R & { __SIGIL_BRAND__: SigilBrandOf<T> }>
  : never;

/** Helper to append label into a class. */
type AppendLabel<L extends string> = {
  readonly __SIGIL_BRAND__: Prettify<{ [K in L]: true }>;
};

/** -----------------------------------------
 *  Manual pattern types
 * ----------------------------------------- */

/** Update '__SIGIL_BRAND__' field when manual typing is used. */
export type UpdateSigilBrand<
  L extends string,
  P extends ISigilInstance,
> = Prettify<SigilBrandOf<P> & { [K in L]: true }>;

/** -----------------------------------------
 *  Generic types
 * ----------------------------------------- */

/**
 * Extract the compile-time brand map from a sigil constructor `S`.
 *
 * @typeParam S - A sigil constructor type (e.g. `typeof SomeSigilClass`).
 * @returns The brand record carried on the constructor's instance type (e.g. `{ User: true, Admin: true }`).
 *
 * @remarks
 * - This helper is used purely at the type level to compute the set of brand keys
 *   that should be propagated to derived sigils.
 * - If `S` does not carry a `__SIGIL_BRAND__`, the resulting type is `never` and `IfNever<>`
 *   collapses it to an empty record.
 */
export type SigilBrandOf<S> = IfNever<
  S extends { readonly __SIGIL_BRAND__: infer Brand } ? Brand : never,
  Record<string, true>
>;

/**
 * Generic type for class constructors used by the Sigil utilities.
 *
 * - `T` is the instance type produced by the constructor.
 * - `P` is the tuple of parameter types accepted by the constructor.
 *
 * @template T - Instance type produced by the constructor (defaults to `object`).
 * @template P - Parameter tuple type for the constructor.
 */
export type Constructor<T = object, P extends any[] = any[]> = new (
  ...args: P
) => T;

/** Helper type to prettify value */
export type Prettify<T> = { [K in keyof T]: T[K] } & {};

/** Helper type to prettify value, handles nested '__SIGIL_BRAND__' field */
export type PrettifyBrand<T> = {
  [K in keyof T]: K extends '__SIGIL_BRAND__' ? PrettifyBrand<T[K]> : T[K];
} & {};

/** Helper type to replace 'never' with another type */
type IfNever<T, R = {}> = [T] extends [never] ? R : T;
